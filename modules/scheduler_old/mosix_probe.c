/*
 *  Kerrighed/modules/scheduler_old/mosix_probe.c
 *
 *  Copyright (C) 1999-2006 INRIA, Universite de Rennes 1, EDF
 *  Copyright (C) 2006-2007 Louis Rilling - Kerlabs
 */

/** Processor load computation.
 *  @file mosix_probe.c
 *
 *  Implementation of processor load computation functions.
 *  It is a simplified version of the MOSIX functions.
 *
 *  Original work by Amnon Shiloh and Amnon Barak.
 *
 *  @author Louis Rilling, Renaud Lottiaux
 */

#include <linux/sched.h>
#include <linux/kernel.h>
#include <linux/string.h>
#include <linux/rcupdate.h>
#include <kerrighed/sched.h>
#include <kerrighed/pid.h>

#include <hotplug/hotplug.h>
#include <procfs/dynamic_node_info_linker.h>

#include "scheduler.h"
#include "mosix_probe_types.h"
#include "analyzer.h"


/* Load informations readable from outside in the cluster */
unsigned long cpu_speed = 1;  /* Speed of each CPU */

unsigned long mosix_mean_load;   /* Load computed and used locally:
				  * increases slowly, decreases quickly */
unsigned long mosix_upper_load;  /* Load given to the outside:
				  * increases quickly, decreases slowly */

unsigned long mosix_norm_mean_load;   /* Normalized mean load */
unsigned long mosix_norm_upper_load;  /* Normalized upper load */

/* unsigned int accurate_use;    /\* Amount of CPU used efficiently -- not */
/*                                *  really computed yet *\/ */

unsigned long mean_load = 0; /* Value scaled by MEAN_LOAD_SCALE */
unsigned long upper_load = 0;

/* Load accumulators which are the basis to compute the machine load */
unsigned long load_adder;
unsigned int load_ticks = CF;
/* unsigned int cpu_use; */

/* Stabilizing factor to compute the exported load:
 * load generated by one process
 */
/* unsigned long stable_export; */
unsigned long mosix_single_process_load;
unsigned long mosix_norm_single_process_load;


static __inline__ unsigned long new_mean_load(unsigned long old_load,
					      unsigned long new_load)
{
	return ((old_load * MEAN_LOAD_DECAY + new_load * MEAN_LOAD_NEW_DATA)
		/ (MEAN_LOAD_DECAY + MEAN_LOAD_NEW_DATA));
}


static __inline__ unsigned long new_upper_load(unsigned long old_load,
					       unsigned long new_load)
{
	return ((old_load * UPPER_LOAD_DECAY + new_load * UPPER_LOAD_NEW_DATA)
		/ (UPPER_LOAD_DECAY + UPPER_LOAD_NEW_DATA));
}


static __inline__ unsigned new_cpu_use(unsigned old_use,
				       unsigned new_use)
{
	return ((old_use * CPU_USE_DECAY + new_use * CPU_USE_NEW_DATA
		 + CPU_USE_DECAY + CPU_USE_NEW_DATA - 1)
		/ (CPU_USE_DECAY + CPU_USE_NEW_DATA));
}


/** Function to update the processor load generated by each process, according
 *  to their stats.
 *
 *  @param ticks   Number of clock ticks since the last update.
 */
static void update_processes_load(unsigned int ticks)
{
	struct task_struct *tsk;
	struct krg_sched_info *info;
	struct mosix_probe_info *p;

	rcu_read_lock();

	for_each_process(tsk) {
		if (unlikely(tsk->exit_state))
			continue;
		if (unlikely(!(tsk->pid & GLOBAL_PID_MASK)))
			continue;
		if (unlikely(!(info = rcu_dereference(tsk->krg_sched))))
			continue;

		p = &info->mosix_probe;

		if (p->last_on) {
			p->ran += ticks + 1 - p->last_on;
			p->last_on = 1;
		}

		p->load = new_mean_load(p->load,
					(p->ran * PROCESS_MEAN_LOAD_SCALE * CF)
					/ ticks);
		p->ran = 0;
	}

	rcu_read_unlock();
}


/** Function to compute load stats of the last execution period of a process.
 *  We only monitor Kerrighed processes.
 *
 *  @param tsk   Process concerned.
 */
static void kcb_process_off(struct task_struct * tsk)
{
	struct krg_sched_info *info;
	struct mosix_probe_info *p;

	rcu_read_lock();
	if (likely(info = rcu_dereference(tsk->krg_sched))) {
		p = &info->mosix_probe;
		p->ran += load_ticks + 1 - p->last_on;
		p->last_on = 0;
	}
	rcu_read_unlock();
}


/** Function to initialize load stats of a process for a new execution period.
 *  We only monitor kerrighed processes.
 *
 *  @param tsk   Process concerned.
 */
static void kcb_process_on(struct task_struct * tsk)
{
	struct krg_sched_info *info;

	rcu_read_lock();
	if (likely(info = rcu_dereference(tsk->krg_sched)))
		info->mosix_probe.last_on = load_ticks + 1;
	rcu_read_unlock();
}


#if 0
/** Evaluate the load of a remote node with an extra process load.
 *  @author Renaud Lottiaux
 *
 *  @param  tsk           Process we would like to put on the distant node.
 *  @param  node_id       Node to put the process on.
 */
unsigned long eval_load_on_remote_node(struct task_struct *tsk,
				       kerrighed_node_t node_id)
{
	krg_dynamic_node_info_t *node_info;
	struct ping_struct * p;
	unsigned long process_load = CF;

	if (tsk && tsk->krg_task) {
		p = &tsk->krg_task->aragorn->ping;
		if (p->load != 0)
			process_load = p->load;
	}

	node_info = get_dynamic_node_info(node_id);

	/* Right now, just add the local load. I will compute some stuff depending
	 * on the CPU speed later.
	 */

	return node_info->mosix_load + process_load;
}
#endif


#if 0
/** Function to update the processor load of the node.
 *  It is called approximatively every CF clock ticks. (CF being equal
 *  to HZ, called every second)
 */
ping_info_msg_t old_mp_calc_load(void)
{
	unsigned long new_local_load;
	unsigned long new_local_mosix_load;
	unsigned new_accurate_use;
	unsigned long scaled_load;
	ping_info_msg_t info;
	unsigned long load;
	unsigned int ticks;
	unsigned use;

	load = load_adder;   /* Accumulated number of processes
			      * since last call */
	ticks = load_ticks;  /* Number of clock ticks since last call */
	use = cpu_use;       /* Accumulated (ticks * num_cpu) efficiently used
				since last call -- not really computed */

	/* Reset the stats for the next period */
	load_adder = 0;
	load_ticks = 0;
	cpu_use = 0;

	/* Make the load machine-speed and time-of-measure independent */
	load = (load * CF * STD_SPD) / (ticks * cpu_speed * num_online_cpus());

	scaled_load = load * MEAN_LOAD_SCALE;

	if (scaled_load > mean_load)
		mean_load = new_mean_load(mean_load, scaled_load);
	else
		mean_load = scaled_load;

	if (load >= upper_load)
		upper_load = load;
	else
		upper_load = new_upper_load(upper_load, load);

	/* not used */
	new_accurate_use = new_cpu_use(accurate_use, use);

	new_local_mosix_load = (((upper_load + stable_export)
				 * CF * num_online_cpus())
				/ new_accurate_use);

	new_local_load = (mean_load + MEAN_LOAD_SCALE / 2) / MEAN_LOAD_SCALE;
	new_local_load = ((new_local_load * CF * num_online_cpus())
			  / new_accurate_use);

	update_processes_load(ticks);

	/* Make the new load cluster-readable */

/*   local_load = new_local_load; */
/*   local_mosix_load = new_local_mosix_load; */
/*   accurate_use = new_accurate_use; */

/*   info.node = kerrighed_node_id; */
/*   info.load = local_mosix_load; */
/*   info.cpu_speed = cpu_speed; */
/*   info.num_cpus = num_online_cpus(); */
/*   info.cpu_use = accurate_use; */

	return info;
}
#endif /* 0 */


/** Function to update the processor load of the node.
 *  It is called approximatively every CF clock ticks. (CF being equal
 *  to HZ, called every second)
 */
static void mp_calc_load(void)
{
	unsigned long scaled_load;
	unsigned long load;
	unsigned int ticks;
/* 	unsigned use; */

	load = load_adder;   /* Accumulated number of processes
			      * since last call */
	ticks = load_ticks;  /* Number of clock ticks since last call */
/* 	use = cpu_use;       /\* Accumulated (ticks * num_cpu) efficiently used  */
/* 				since last call -- not really computed *\/ */

	/* Reset the stats for the next period */
	load_adder = 0;
	load_ticks = 0;
/* 	cpu_use = 0; */

	/* Make the load time-of-measure independent */
	load = (load * CF) / ticks;

	scaled_load = load * MEAN_LOAD_SCALE;

	if (scaled_load > mean_load)
		mean_load = new_mean_load(mean_load, scaled_load);
	else
		mean_load = scaled_load;

	if (load >= upper_load)
		upper_load = load;
	else
		upper_load = new_upper_load(upper_load, load);

	mosix_mean_load = (mean_load + MEAN_LOAD_SCALE / 2) / MEAN_LOAD_SCALE;
/* 		+ mosix_single_process_load; */
	mosix_upper_load = upper_load;
/* 		+ mosix_single_process_load; */

	mosix_norm_mean_load = (mosix_mean_load * STD_SPD) / cpu_speed;
	mosix_norm_upper_load = (mosix_upper_load * STD_SPD) / cpu_speed;

	update_processes_load(ticks);
}


/** Function to accumulate load stats at each clock tick.
 *  Called each time calc_load is called.
 *  This function is called in the timer interrupt,
 *  with the xtime_lock write lock held.
 *
 *  @param ticks   Clock ticks since last called.
 */
static void kcb_accumulate_load(unsigned long ticks)
{
	unsigned long load;

	load_adder += nr_running();
/* 	cpu_use += ticks * num_online_cpus(); */
	load_ticks += ticks;

	//CF is equal to HZ, which means load is computed every second
	if (load_ticks >= CF) {
		mp_calc_load();

		load = mosix_mean_load;

		if (load >= ALARM_THRESHOLD)
			send_alarm_to_analyzer();
	}
}


/** Function to initialize load informations of a process.
 *
 *  @param tsk   Process concerned
 *  @param p     Ping struct of the process.
 */
int mosix_probe_init_info(struct task_struct *task, struct krg_sched_info *info)
{
	struct mosix_probe_info *p;

	p = &info->mosix_probe;

	p->load = 0;
	if (task->state == TASK_RUNNING)
		p->last_on = load_ticks + 1;
	else
		p->last_on = 0;
	p->ran = 0;

	return 0;
}


void mosix_probe_init(void)
{
	load_adder = CF * (nr_running() - 1);
/* 	accurate_use = CF * num_online_cpus(); */
/* 	cpu_use = CF * num_online_cpus(); */
	mosix_single_process_load = CF;
	mosix_norm_single_process_load =
		mosix_single_process_load * STD_SPD / cpu_speed;

	//called each time calc_load is called
	hook_register(&kh_calc_load, kcb_accumulate_load);
	//called when a process is added to the run queue
	hook_register(&kh_process_on, kcb_process_on);
	//called when a process is removed from the run queue
	hook_register(&kh_process_off, kcb_process_off);
}
